package main

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	yaml "gopkg.in/yaml.v2"
)

const maxWidth = 80

var (
	red    = lipgloss.AdaptiveColor{Light: "#FE5F86", Dark: "#FE5F86"}
	indigo = lipgloss.AdaptiveColor{Light: "#5A56E0", Dark: "#7571F9"}
	green  = lipgloss.AdaptiveColor{Light: "#02BA84", Dark: "#02BF87"}
)

type Styles struct {
	Base,
	HeaderText,
	Status,
	StatusHeader,
	Highlight,
	ErrorHeaderText,
	Help lipgloss.Style
}

func NewStyles(lg *lipgloss.Renderer) *Styles {
	s := Styles{}
	s.Base = lg.NewStyle().
		Padding(1, 4, 0, 1)
	s.HeaderText = lg.NewStyle().
		Foreground(indigo).
		Bold(true).
		Padding(0, 1, 0, 2)
	s.Status = lg.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(indigo).
		PaddingLeft(1).
		MarginTop(1)
	s.StatusHeader = lg.NewStyle().
		Foreground(green).
		Bold(true)
	s.Highlight = lg.NewStyle().
		Foreground(lipgloss.Color("212"))
	s.ErrorHeaderText = s.HeaderText.
		Foreground(red)
	s.Help = lg.NewStyle().
		Foreground(lipgloss.Color("240"))
	return &s
}

type Template struct {
	AWSTemplateFormatVersion string `yaml:"AWSTemplateFormatVersion"`
	Transform                string `yaml:"Transform"`
	Description              string `yaml:"Description"`
}

type Globals struct {
	Function Function `yaml:"Function"`
}

type Function struct {
	Name          string   `yaml:"FunctionName"`
	TimeOut       int      `yaml:"Timeout"`
	MemorySize    int      `yaml:"MemorySize"`
	Runtime       string   `yaml:"Runtime"`
	Architectures []string `yaml:"Architectures"`
	Handler       string   `yaml:"Handler"`
}

type Model struct {
	form          *huh.Form
	lg            *lipgloss.Renderer
	styles        *Styles
	architecture  string
	projectName   string
	resource      string
	resourceName  string
	runtime       string
	templateExist bool
}

func NewModel() Model {
	m := Model{}
	m.templateExist = doesTemplateExist().(bool)

	m.form = huh.NewForm(
		huh.NewGroup(
			huh.NewNote().
				Title("Stratus").
				Description("Stratus simplifies serverless app development on AWS.\n\n").
				Next(true).
				NextLabel("Start"),
		),
		huh.NewGroup(
			huh.NewInput().
				Key("projectName").
				Title("Project name").
				Value(&m.projectName).
				Validate(
					func(s string) error {
						if s == "" {
							return fmt.Errorf("project name is required")
						}
						return nil
					},
				),
		).WithHideFunc(func() bool {
			return m.templateExist
		}),
		huh.NewGroup(
			huh.NewSelect[string]().
				Key("resource").
				Value(&m.resource).
				Options(huh.NewOptions("Lambda", "API Gateway", "DynamoDB")...).
				Title("What serverless resource would you like to create?"),
		),
		huh.NewGroup(
			huh.NewInput().
				Key("name").
				Title("Resource name").
				Value(&m.resourceName).
				Validate(
					func(s string) error {
						if s == "" {
							return fmt.Errorf("resource name is required")
						}
						return nil
					},
				),
		).WithHideFunc(func() bool {
			return m.resource == ""
		}),
		huh.NewGroup(
			huh.NewSelect[string]().
				Key("architecture").
				Value(&m.architecture).
				Options(huh.NewOptions("x86_64", "arm64")...).
				Title("What architecture would you like to use?"),
		),
		huh.NewGroup(
			huh.NewSelect[string]().
				Key("runtime").
				Value(&m.runtime).
				Options(huh.NewOptions(
					"nodejs20.x",
					"nodejs18.x",
					"nodejs16.x",
					"python3.12",
					"python3.11",
					"python3.10",
					"python3.9",
					"python3.8",
					"provided.al2023",
				)...).
				Title("What runtime would you like to use?"),
		).WithHideFunc(func() bool {
			return m.resource != "Lambda"
		}),
	).WithProgramOptions(tea.WithAltScreen())
	return m
}

func (m Model) Init() tea.Cmd {
	return m.form.Init()
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	}
	form, cmd := m.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		m.form = f
	}
	if m.form.State == huh.StateCompleted {
		return m, tea.Quit
	}
	return m, cmd
}

func (m Model) View() string {
	if m.form.State == huh.StateCompleted {
		return createResource(m)
	}

	return m.form.View()
}

func createResource(m Model) string {
	if m.templateExist {
		return "Using existing template.yaml\n"
	} else {
		err := createTemplate()
		if err != nil {
			return fmt.Sprintf("Error creating template: %v\n", err)
		}
		s := "Created new template.yaml\n"
		return s
	}
}

func doesTemplateExist() tea.Msg {
	_, err := os.Open("template.yaml")
	return !os.IsNotExist(err)
}

func createTemplate() error {
	f, err := os.Create("template.yaml")
	if err != nil {
		return err
	}
	defer f.Close()

	encoder := yaml.NewEncoder(f)

	err = encoder.Encode(Template{
		AWSTemplateFormatVersion: "2010-09-09",
		Transform:                "AWS::Serverless-2016-10-31",
		Description:              "Generated by Stratus",
	})
	if err != nil {
		return err
	}
	return nil
}

func main() {
	p := tea.NewProgram(NewModel())
	_, err := p.Run()
	if err != nil {
		fmt.Printf("Shit! It broke: %v", err)
	}
}
